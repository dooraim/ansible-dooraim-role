# Move all the git untracked files to a folder _untracked in the current folder
function ff_move_untracked_files()
{
    SAVEIFS=$IFS
    IFS=$(echo -en "\n\b")
    if [ ! -d _untracked ]; then
        echo "Folder _untracked does not exist. Wrong root folder?"
        return 1
    fi
    for f in $(git ls-files -o | grep -v -E "untracked|directory|sshinit"); do
        mkdir -p "_untracked/$(dirname ${f})"
        echo "Move $(basename "${f}") [`du -k "${f}" | cut -f1` kB]...";
        mv "${f}" "_untracked/${f}"
    done
    echo "DONE"
    IFS=$SAVEIFS
}

# Replace text in place with confirmation
function ff_ssed()
{
  sed s/$1/$2/g $3 | grep $2
  read -p Confirm? answ
  if [ comfirm ]; then
    sed -i s/$1/$2/g $3
    grep "$2" "$3"
  fi
}

function ff_bak() {
    for f in ${@}; do
        echo "Backing up ${f}"
        mv "${f}" "${f}.bak"
    done
}

function ff_unbak() {
    for f in ${@}; do
        echo "Unbacking up ${f%.bak}"
        mv "${f}" "${f%.bak}"
    done
}

function ff_ncdu()
{
  folder=.
  if [ ! -z "$1" ]; then
    folder="$1"
  fi

     du -k --max-depth=1 "$folder" 2> /dev/null | sort -nr | awk '
     BEGIN {
        split("KB,MB,GB,TB", Units, ",");
     }
     {
        u = 1;
        while ($1 >= 1024) {
           $1 = $1 / 1024;
           u += 1
        }
        $1 = sprintf("%.1f %s", $1, Units[u]);
        print $0;
     }
    '
}

function ff_tip()
{
  # TIPS_FILE=$(find $DATA_DIR/linux/cheatsheets/personal | sort -R | head -n 1)
  TIPS_FILE=~/.config/cheat/cheatsheets/personal/tips
  awk -v RS='# ' -v TOPIC=$(basename "$TIPS_FILE") '
  BEGIN { srand(); } 
  rand() < 1.0/NR { s=$0; }  
  END { print "# ("TOPIC") "s; }
  ' "$TIPS_FILE" | sed -Ez '$ s/\n+$/\n/' | cowsay -W 120 -n
}

## Audio video manipulation
ff_convert_to_x264() {
    ffmpeg -i "$1" -c:v libx264 -preset medium -crf 22 -c:a copy "${1%.*}_x264.mkv"
}

ff_convert_to_x265() {
    ffmpeg -i "$1" -c:v libx265 -preset medium -crf 28 -c:a aac -b:a 128k "${1%.*}_x265.mkv"
}

ff_convert_to_mp3() {
    ffmpeg -i "$1" -vn -ac 2 -ar 44100 -ab 192k "${1%.*}.mp3"
}

ff_extract_audio() {
    ffmpeg -i "$1" -vn -c:a copy "${1%.*}.mp3"
}

ff_stabilize_video() {
    ffmpeg -i "$1" -vf vidstabdetect -f null -
    ffmpeg -i "$1" -vf vidstabtransform "$1.stab.mkv"
    rm transforms.trf
}

# Extract a page from a PDF to a file extracted-pages.pdf
function ff_extract_page_pdf
{
    mkdir -p img
    #pdftops "$1" - | psselect -p$2 | ps2pdf - | pdfimages -j - img/img
    pdftk "$1" cat "$2" output extracted-pages.pdf
}


# Extract a page from a djvu to a file extracted-pages.pdf
function ff_extract_page_pdf
{
    ddjvu -page=$2 -format=tiff "$1" temp.tif
    convert -limit area 1 temp.tif ${1%%.*}-page$2.png
    rm temp.tif
}


# Transform a white background to transparent in a PDF? file
function ff_remove_latex_background()
{
  convert "$1" -fuzz 50% -transparent white  "new_$1"
}

####### MANJARO #######

# Enable/Disable predictable network interface names
function ff_toggle_eth0()
{
  if [ -e /etc/udev/rules.d/80-net-setup-link.rules ]; then
    sudo rm /etc/udev/rules.d/80-net-setup-link.rules
    echo "Predictable network interface names de-activated. Reboot to apply changes."
  else
    sudo ln -s /dev/null /etc/udev/rules.d/80-net-setup-link.rules
    echo "Predictable network interface names activated. Reboot to apply changes."
  fi
}

# Remove unused packages from cache, empty AUR cache, remove unused dependencies
function ff_pacman_clean_up()
{
    yay -Sc
    echo "Remove unused dependencies (sudo)?"
    confirm && sudo pacman -Rs `pacman -Qtdq`
}

# Toggle between A2DP and HSP/HFP bluetooth profile (to enable mic)
function ff_toggle_bluetooth_profile() {
    aptx=`pactl list | grep Active | grep aptx`
    card=`pactl list | grep "Name: bluez_card." | cut -d ' ' -f 2`

    if [ -n "$aptx" ]; then
        echo "Switching $card to msbc..."
        pactl set-card-profile $card headset-head-unit-msbc
        echo "...done"
    else
        echo "Switching $card to aptx..."
        pactl set-card-profile $card a2dp-sink-aptx
        echo "...done"
    fi
}

## TASKWARRIOR
task-init-local-db() {
    # start a local ($PWD) tasklist
    if [ -e '.taskrc' ]; then
        echo '[ERROR] a Taskwarrior config already exists here.'
    else
        # include global settings
        if [ -e "$HOME/.taskrc" ]; then
            # shellcheck disable=SC2016
            echo 'include $HOME/.taskrc' > .taskrc
        fi
        # use local DB
        echo "data.location=$(pwd)/.taskwarrior" >> .taskrc
        # create local DB if needed
        if [ ! -e '.taskwarrior' ]; then
            mkdir .taskwarrior
        fi
    fi
}

task-init-local-project() {
    # set local default project name
    # ARG1: default project name
    #
    if [ -e '.taskrc' ]; then
        echo '[ERROR] a Taskwarrior config already exists here.'
        return 1
    fi
    local pro="${1:-$(basename $(pwd))}"
    # include global settings
    if [ -e "$HOME/.taskrc" ]; then
        # shellcheck disable=SC2016
        echo "include $HOME/.taskrc" > .taskrc
    fi
    # set local project override
    echo "default.project=$pro" >> .taskrc
    echo "default.command=list project:$pro" >> .taskrc
    task context define "$pro" "project:$pro"
}

task-local() {
    # use local $PWD tasklist, instead of global
    if [[ "$PWD" != "$HOME" && -e ".taskrc" ]]; then
        task rc:.taskrc "$@"
    else
        task "$@"
    fi
}
## END TASKWARRIOR

ff_pipewire_recording() {
    pactl load-module module-null-sink media.class=Audio/Sink sink_name=recording sink_properties=device.description=recording
    pactl load-module module-loopback source=alsa_input.pci-0000_00_1f.3.analog-stereo sink=recording 
    pactl load-module module-combine-sink sink_name=combined sink_properties=device.description=combined slaves=bluez_output.58_FC_C6_0D_26_91.a2dp-sink
}

ff_record() {
    mktmp 
    pw-cat -r recording.wav
    lame -V0 recording.wav $DATA_DIR/audio/recordings/$(date --iso-8601=seconds)_recording.mp3
}